#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 29 18:37:18 2017

@author: cw
"""
import random
def sample(probList,eventList):
    addedProb=[]
    prob=probList
    events=eventList
    for id_,i in enumerate(prob):
    
        if id_==0:
            addedProb.append(i)
        else:
            nex=i+addedProb[id_-1]
            #print(nex)
            addedProb.append(nex)
    a=[0 ] 
    zaddedProb=a+addedProb   
   # print(zaddedProb)
    x=random.uniform(0, 1)
    for zidx,zi in enumerate(zaddedProb):
        if zi<x<zaddedProb[zidx+1]:
        
            return (events[zidx])
        else:
         continue

import numpy as np
x=np.random.exponential(0.12)
#print(x)

#define rate matrix
Q=[[-1.916,0.541,0.787,0.588],[0.148,-1.069,0.415,0.506],[0.286,0.170,-0.591,0.135],[0.525,0.236,0.594,-1.355]]
#convert the rate matrix into a numpy array
q=np.asarray(Q)
#print(q[0])

#print(nt_dic["a"])
# function for running CTMC. This function acepts initail state, rate matrix and a branch length to simulate
class ctmc():
    # deifne a nucl dictionary to acessing rate matrix
    
    sampledStates=[]
    sim_len=0
    def __init__(self,in_state,q_mat,branch_len):
        # initilize all the variables
        self.q_mat=q_mat
        self.branch_len=branch_len
        self.sampledStates.append(in_state)
        
    def next_state(self) :   
      nt_dic={"a":0,"c":1,"t":2,"g":3}
      nt_int=nt_dic[self.sampledStates[-1]]
      #print(q_mat[nt_int][nt_int])
      rate=self.q_mat[nt_int][nt_int]
      #print(rate)
      # print(nt_int)
      wating_time=np.random.exponential(1/abs(rate))
   # print(wating_time)
      length=wating_time
      prob_list=[]
      state_list=[]
      for key in nt_dic:
     
       nt_number=(nt_dic[key])
       if nt_number!=nt_int:
            print(nt_number)
            prob=self.q_mat[nt_int][nt_number]/abs(self.q_mat[nt_int][nt_int])
            prob_list.append(prob)
            state_list.append(key)
            
      #print(state_list)
      #print(prob_list)
      self.sim_len=self.sim_len+length
      sampled_s=sample(prob_list,state_list)
      self.sampledStates.append(sampled_s)

# defines the chain object      
CTMC=ctmc("a",q,0.7)

# run chain untill specified branch length is exceded
while(CTMC.sim_len<CTMC.branch_len):
 CTMC.next_state()

print(CTMC.sampledStates) 
